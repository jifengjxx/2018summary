###html 基础

* 超文本标记语言 ， 不是编程语言
* 标签名不区分大小写
* 元素：  开始标签到结束标签的所有代码，即由开始标签、结束标签、属性以及内容组成
* 元素分类：块级元素、行内元素、行内块元素   
* 对于块级元素，即使设置了宽高，也会独占一行
* 标签嵌套的基本顺序应该是：“*块级标签*>*行内块标签*>*行内标签*”
* HTML文档流中的标签元素遵循“从左到右、从上到下”的排列次序

##### html基本文档结构

```js
<!DOCTYPE html>
<html lang="en">
     <head>
           <meta charset="utf-8">
               <title></title>
    </head>
   <body></body>
 </html>	
```

* <!DOCTYPE html>文档声明

* 它的目的是要告诉标准通用标记语言解析器，它应该使用什么样的文档类型定义（DTD）来解析文档。

  <!DOCTYPE> 声明必须是 HTML 文档的第一行，位于 <html> 标签之前。 

* 作用：声明文档的解析类型(document.compatMode)，避免浏览器的怪异模式。 

* 如：\<html lang="zh-cn">、\<html lang="zh">、\<html lang="en">这样的形式，分别表示将语言类型设置为“简体中文”、“中文”、“英文”。

##### 基础标签

* ···<header><article><footer><main><aside><small><nav><section>

* ···<img  src=""/>

* \<a> 标签主要用于超链接，href    target: self  blank parent 

* table 标签      行 tr    单元格 标题 是  th    内容是td   caption 表格主题表格之外

* cellpadding  内容与单元格间距    cellspacing 单元格与单元格之间    cellspacing="0" cellpadding="10" 

* rowspan 单元格跨行  <td rowspan="2">东腾</td> 

* colspan 单元格跨列    <td colspan="2">电话</td>

* ····<details>        <summary>      </summary>        </details>

* ···<fieldset>  <legend>   </legend>   </fieldset>

* ···< progress > 

* ```
  <main>
  	<span>下载中：</span>
  	<progress>
  </main>

  <main>
  	<span>当前进度：</span>
  	<progress value="50" max="100">
  </main>
  ```

* < audio >标签是一个“行内块级元素”,它用于在页面中加载音频文件

*  autoplay  controls  loop  muted   src   media  

* <video> 标签是一个“行内块级元素”,它用于在页面中加载*视频*文件



##### 表单

* action  规定提交表单的地址  url 提交页面

* method get   post 附加html headers上

* target _blank新窗口打开 _self当前页面打开 _parent父框架中打开  _top在整个窗口中打开

*  autocomplete  

* 常用属性

*  readonly disabled checked size  autocomplete autofocus form  multiple

* required 

* ···<datalist>

* ```html
  <form name="myForm" action="javascript:(void);" method="POST" target="_blank">
  	<input type="text" name="cityIpt" placeholder="请选择/输入您喜欢的城市：" size="25" list="citys">
  	<datalist id="citys">
  		<option>北京</option>
  		<option>上海</option>
  		<option>成都</option>
  		<option>香港</option>
  		<option>厦门</option>
  		<option>昆明</option>
  		<option>大理</option>
  	</datalist>
  </form>
  ```

* output

* ···<output  for=”绑定对象“>0</output>···





##### url  href  src 的区别

* URL(Uniform Resource Locator) 统一资源定位符 ：

互联网上的每个文件都有一个唯一的URL，它包含的信息指出文件的位置以及浏览器应该怎么处理它。 分类:    绝对URL 和 相对URL（以包含URL本身的文件夹的位置为参考点） 

* .href (Hypertext Reference)网络资源的位置，

  **浏览器识别当前资源是一个样式表，页面解析不会暂停**（由于浏览器需要样式规则去画或者渲染页面，渲染过程可能会被被暂停）。这与把css文件内容写在<style>标签里不相同，**因此建议使用link标签而不是@import来吧样式表导入到html文档里。**

* src (Source)属性仅仅 嵌入当前资源到当前文档元素定义的位置，**在浏览器下载，编译，执行这个文件之前页面的加载和处理会被暂停。**这个过程与把js文件放到<script>标签里类似。这也是建议把JS文件放到底部加载的原因。当然，img标签页与此类似。浏览器暂停加载直到提取和加载图像。

#####**http请求过程**

​    a. 域名解析

​    b. 发起TCP的3次握手

​    c. 建立TCP连接后发起http请求

​    d. 服务器端响应http请求，浏览器得到html代码

​    e. 浏览器解析html代码，并请求html代码中的资源

​    f. 浏览器对页面进行渲染呈现给用户

#####**行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？**

 答案解析： 

行内元素：a  b  span  img  input  select  strong 

块级元素：div  ul  ol  li  dl  dt  dd  h1  h2  h3  h4  p  等 

空元素：<br>  <hr>  <img>  <link> <meta> 

#####**如何区分 HTML 和 HTML5？** 

答案解析： 

1）在文档类型声明上不同： HTML是很长的一段代码，很难记住，而HTML5却只有简简单单的声明，方便记忆。

 2）在结构语义上不同： HTML：没有体现结构语义化的标签，通常都是这样来命名的<div id="header"></div>，这样表示网站的头部。 HTML5：在语义上却有很大的优势。提供了一些新的标签，比如：<header><article><footer> 



#####**简述一下你对HTML语义化的理解？**  

答案解析： 

1）用正确的标签做正确的事情； 2）html语义化让页面的内容结构化，结构更清晰，便于对浏览器、搜索引擎解析； 3）即使在没有样式css情况下也以一种文档格式显示，并且是容易阅读的； 4）搜索引擎的爬虫也依赖于HTML标记来确定上下文和各个关键字的权重，利于SEO； 5）使于都源代码的人对网站更容易将网站分块，便于阅读维护理解。

#####HTML 和 XHTML 有什么区别？

为了规范HTML，W3C结合XML制定了XHTML 1.0标准，这个标准没有增加任何新的tag，只是按照XML的要求来规范HTML。

XHTML中的标签都必须被正确地嵌套,HTML中的某些标签可以彼此不正确的嵌套。 
XHTML中的所有标签必须要关闭。 
XHTML中规范定义：标签名和属性对大小写敏感,所有XHTML标签名必须用小写字母。 
XHTML文档必须拥有根元素。 
XHTML中标签的属性值要使用双引号”。



#####Html5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？

答：新特性，新增元素：

1）内容元素：article、footer、header、nav、section

2）表单控件：calendar、date、time、email、url、search

3）控件元素：webworker，websockt，Geolocation

移除元素：

1）显现层元素：basefont，big，center，font，s，strike，tt，u

2）性能较差元素：frame，frameset，noframes





### css基础

* CSS，全称“Cascading Style Sheets （层叠样式表）”，
* 选择符  样式属性   样式属性值

##### 引入方式

* 行内样式   内嵌式  外链样式  导入式
* 外链样式 通过 href属性值访问   **<link>**  
* ```<link rel="stylesheet" href="stylesheets/index.css">```

###### 导入式

```html
<!DOCTYPE html>
<html lang="zh-cn">
<head>
	<meta charset="UTF-8">
	<title>Document</title>
	<style type="text/css">
		@import url(stylesheets/index.css);
	</style>
</head>
<body>
	<div></div>
</body>
</html>
```

###### 优先级

```
 !important >行内样式 > 内嵌样式 > 外链样式 > 导入样式
```

###### <link>标签的优点

```
1. 简化了DOM结构，实现了内容和表现的分离，使HTML和CSS文件结构更加清晰，利于维护
2. 大大减少了CSS代码的编写量。项目越大，这一点体验得越明显
3. <link>可以和其它<link>、JS文件以及<body>内的内容进行多线程加载，使得加载速度更快
4. 利于项目整体风格的调整，维护起来也更加便捷。单文件修改，全网站（应用）生效
5. 浏览器会将CSS文件进行缓存，进一步地减少了加载所需时间
6. 可以根据需要利用JavaScript或Media动态的组合所需的CSS文件
7. 对搜索引擎友好，有利于SEO
```

###### 区别

```
1. <link> 除了加载 CSS 文件以外，它还能加载其它类型文件，如“icon”、“index”、“rss”等，它还能通过将“rel”的值设置为“prefetch”执行文件的预加载，而“@import”只能加载CSS文件。
2. <link> 在现代的浏览器中是多线程加载的，也就是说在通过该标签加载一个文件的时候<body>标签内的 DOM（文档对象模型） 也在执行同步的加载。而“@import”是一种“线性”的加载，加载效率不如<link>的方式。
3. 无论在老版本的浏览器中，或者在一些非主流的浏览器中，页面都是会首先加载<link>标签引用的样式并渲染，而“@import”在这些浏览器中会最后才去渲染CSS的样式，这样会让用户首先看到一个无样式的HTML界面，等CSS渲染完成之后才能最终看到完整样式的界面，导致用户体验不佳。
4. <link>作为一个标签，也就是一个DOM元素，是可以通过JavaScript进行操作的（如增加、删除<link>标签，修改<link>的属性值等）。而“@import”写在<style>标签内部或CSS文件内（写在<style>标签内和CSS文件内的写法一致），是无法通过JavaScript进行操作的。
```

##### 选择器

同级元素选择器

- `+` ：选择该选择器相邻的下一个选择器。
- `~`：选择该选择器后的所有同级选择器。

属性选择器

- `[attr] {…}`：用于选取带有指定属性的元素
- `[attr  = val] {…}`：用于选取带有指定属性和值的元素
- `[attr ~= val] {…}`：用于选取属性值中包含指定词汇的元素
- `[attr |= val] {…}`：用于选取带有以指定值开头的属性值的元素，该值必须是整个单词
- `[attr ^= val] {…}`：匹配属性值以指定值开头的每个元素
- `[attr $= val] {…}`：匹配属性值以指定值结尾的每个元素
- `[attr *= val] {…}`：匹配属性值中包含指定值的每个元素



##### 高级选择器

* ：first-letter 选择“块级元素”文本段落中的首个字符，只能对“块级元素”生效。<p>

* :before  : after   插入的内容默认为“行内元素”，如果需要插入文本字符串，则直接将字符串赋值给 `content` 属性，如：`content: 'Hello, world!'`

* :empty    :not

* :checked

* ```css
  [name="myForm"]  > [type="radio"]:checked + label {
      font-size: 20px;
      text-shadow: 1px 1px 2px #000;
  }
  ```

##### 滚动条

* ：：-webkit-scrollbar

* ```css
  /*设置滚动条*/
  body::-webkit-scrollbar {
      width: 20px;
  }
  /*设置滚动条拇指元素*/
  body::-webkit-scrollbar-thumb:vertical {
      border-radius: 5px;
      background: #d3d3d3;
  }

  /*设置滚动条背景元素*/
  body::-webkit-scrollbar-track-piece:vertical  {
      border-radius: 5px;
      background: #808080;
  }
  ```

*  ::input-plachehoder 修改表单占位符颜色

```css
::-webkit-input-placeholder {
    color: #769bff;
}
```

* 修改光标颜色    caret-color:blue;

* ```css
  <input type="text" style="caret-color:blue;" placeholder="请输入文本内容">
  ```




* content 属性attr

  ```css
  <div data-msg="Open this file in Github Desktop.">HOVER</div>
  div:hover:after {
      position: absolute;
      top: calc(100% + 5px);
      left: 0;

      width: 250%;

      font-size: .5em;
      background: #ff4500;
      content: attr(data-msg);
  }
  ```

  通过 attr() 抓取标签属性值。



##### 文本与字体

* 段落首行缩进

  ```
  text-indent: 2em;
  ```

* text-decoration  下滑线

* text-decoration:line-through；在文本中间显示装饰线，相当于删除线

  a 标签去下滑线text-decoration:none; 

* `text-shadow` 属性的作用是给文本添加阴影效果。

  ```css
  text-shadow: H V blur color;
  ```

* white-space 属性设置如何处理元素内的空格符和换行符  normal pre  nowrap

* text-overflow  文本裁切

* ```
  - clip：裁切文本
  - ellipsis：显示省略符号来代表被裁剪的文本         overflow: hidden;
  ```

* 文字两端对齐

* ```
    text-align-last: justify; /*两端对齐*/
    ```
  ```

* 纵向显示文字

* ```
  writing-mode：horizontal-tb | vertical-rl | vertical-lr
  ```

* ​

* 自定义字体

  ```css
     @font-face {
          /*字体名称*/
          font-family: '经典隶变简';
          /*字体路径*/
          src: url('fonts/经典隶变简.TTF');
      }
      @font-face {
          /*字体名称*/
          font-family: '华文行楷';
          /*字体路径*/
          src: url('fonts/华文行楷.ttf');
      }
    div.t1 {
          font: normal bold 20px/50px '经典隶变简';
      }
      div.t2 {
          font: 20px/50px '华文行楷';
      }
  ```






##### 字体组合值

```
可以按顺序设置如下属性：

font-style （使用斜体、倾斜或正常字体）
font-variant （设置小型大写字母的字体显示文本）
font-weight （设置文本的粗细）
font-size/line-height （设置字体的尺寸和行高）
font-family （规定元素的字体系列）
可以不设置其中的某个值，比如 font:100% verdana; 也是允许的。未设置的属性会使用其默认值。

如：

body{ font: italic small-caps bold 14px/24px "microsoft yahei";}

字体：斜体 小型大写字母 粗体 14号大小/24像素行高 微软雅黑

可以不需要每个都写，但是顺序还是要的
```

##### rem   em   px

 

 提示：em 是相对长度单位。相对于当前对象内文本的字体尺寸。如当前对行内文本的字体尺寸未被人为设置，则相对于浏览器的默认字体尺寸。如果是等宽字体（即每个字符的宽度都是一样的），1em 就是1个字符的宽度。通常我们可以这样来理解：如果把某个元素的font-size设为16px，那么1em就等于16px，2em就是32px。



```css
html {
font-size: 62.5%
}

@media only screen and (min-width: 481px) {
html {
font-size:94%!important
}
}

@media only screen and (min-width: 561px) {
html {
font-size:109%!important
}
}

@media only screen and (min-width: 641px) {
html {
font-size:125%!important
}

```

###### em

**em（相对长度单位）**

使用：1、浏览器的默认字体都是16px，那么1em=16px，以此类推计算12px=0.75em，10px=0.625em，2em=32px；

2、这样使用很复杂，很难很好的与px进行对应,也导致书写、使用、视觉的复杂(0.75em、0.625em全是小数点)；

3、为了简化font-size的换算，我们在body中写入一下代码

这样页面中1em=10px,1.2em=12px,1.4em=14px,1.6em=16px，使得视觉、使用、书写都得到了极大的帮助。

例子如下：

 ###### rem

使用：1、浏览器的默认字体都是16px，那么1rem=16px，以此类推计算12px=0.75rem，10px=0.625rem，2rem=32px；

2、这样使用很复杂，很难很好的与px进行对应,也导致书写、使用、视觉的复杂(0.75rem、0.625em全是小数点) ；

3、为了简化font-size的换算，我们在根元素html中加入font-size: 62.5%;

这样页面中1rem=10px,1.2rem=12px,1.4rem=14px,1.6rem=16px;使得视觉、使用、书写都得到了极大的帮助；

例子如下：

运行效果为：

[![wKiom1mpJ1rwyiZmAABS6GuTt0Q253.png-wh_50](https://s5.51cto.com/wyfs02/M01/05/AD/wKiom1mpJ1rwyiZmAABS6GuTt0Q253.png-wh_500x0-wm_3-wmp_4-s_2240265030.png)](https://s5.51cto.com/wyfs02/M01/05/AD/wKiom1mpJ1rwyiZmAABS6GuTt0Q253.png-wh_500x0-wm_3-wmp_4-s_2240265030.png)

特点：

1、rem单位可谓集相对大小和绝对大小的优点于一身

2、和em不同的是rem总是相对于根元素(如:root{})，而不像em一样使用级联的方式来计算尺寸。这种相对单位使用起来更简单。

3、rem支持IE9及以上，意思是相对于根元素html（网页），不会像em那样，依赖于父元素的字体大小，而造成混乱。使用起来安全了很多。









##### 元素的可见性

* visibility  visible：（默认），元素可见。 hidden：元素不可见，仍会占据空间。
* opacity



##### 清除浮动的方法

```
- 1）、父级元素定义 height
  原理：父级元素手动定义 height，就解决了父级元素无法自动获取到高度的问题。 
  优点：简单、代码少、容易掌握 。
  缺点：只适合高度固定的布局，要给出精确的高度，如果高度和父级元素不一样时，会产生问题 。
  建议：不推荐使用，只建议高度固定的布局时使用 。
- 2）、结尾处加空 div 标签，并设置 clear: both
  原理：添加一个空div，利用css提供的clear:both清除浮动，让父级div能自动获取到高度 。
  优点：简单、代码少、浏览器支持好、不容易出现怪问题 。
  缺点：不少初学者不理解原理；如果页面浮动布局多，就要增加很多空div，让人感觉很不好 。
  建议：不推荐使用，但此方法是以前主要使用的一种清除浮动方法 。
- 3）、父级div定义 伪类:after 和 zoom 
      <div class="clearFix">
      	<div class="fl">Float Left</div>
      	<div class="fr">Float Right</div>
      </div>
      <div>Hello, world!</div>
      /*清除浮动*/
      .clearFix {zoom: 1;}
      .clearFix:after {
      	content: '';
      	display: block;
      	height: 0;
      	visibility: hidden;
      	clear: both;
      }
      
      .fl {float: left;}
      .fr {float: right;}
  原理：IE8以上和非IE浏览器才支持 :after，原理和方法2有点类似，zoom(IE专有属性)可解决IE6、7浮动问题。 
  优点：浏览器支持好、不容易出现怪问题（目前：大型网站都有使用，如：腾迅，网易，新浪等等） 。
  缺点：代码多、不少初学者不理解原理，要两句代码结合使用才能让主流浏览器都支持。 
  建议：推荐使用，建议定义公共类，以减少CSS代码。 

- 4）、父级元素定义 overflow:hidden 
  原理：必须定义width或zoom:1，同时不能定义height，使用overflow:hidden时，浏览器会自动检查浮动区域的高度 
  优点：简单、代码少、浏览器支持好 。
  缺点：不能和position配合使用，因为超出的尺寸的会被隐藏。 
  建议：只推荐没有使用position或对overflow:hidden理解比较深的朋友使用。 
- 5）、父级div定义 overflow:auto 
  原理：必须定义width或zoom:1，同时不能定义height，使用overflow:auto时，浏览器会自动检查浮动区域的高度 。
  优点：简单、代码少、浏览器支持好 。
  缺点：内部宽高超过父级div时，会出现滚动条。 
  建议：不推荐使用，如果你需要出现滚动条或者确保你的代码不会出现滚动条就使用吧。 

```



##### 盒子模型

所谓盒子模型，即是将网页布局中的元素（行内/行内块元素）进行拟物化的比喻，一个盒子由内容（content）、内间距（padding）、边框（border）以及外边距（margin）组成。

* CSS盒子模型的类型主要有两个：
  - IE浏览器盒子模型：`box-sizing:border-box;`
  - 标准（W3C，其它主流浏览器）盒子模型（默认）：`box-sizing:content-box;`
* IE盒子模型和标准盒子模型有一定的差异，具体表现在：IE盒子模型的宽度/高度包含了`content`、`padding` 以及 `border`；而标准盒子模型的宽度/高度仅仅包含了`content`

##### border

 ```css
.t4 {
		width:  0px;
		height: 0px;

		border-top: 45px solid transparent;
		border-right: 45px solid green;
		border-bottom: 45px solid transparent;
		border-left: 45px solid purple;
	}
 ```

##### border-radius

##### 元素阴影

```css
box-shadow: h v  blur   范围   color   inset
```



##### 元素背景

* background-image: url(images/1.jpg)

* background-size:240px 120px;

  ````
  - contain
    自动将背景图像填满元素的其中一边，图像的比例保持不变。

  - cover
    在保持图像原始比例的情况下，将元素的背景区域完全覆盖，超出元素宽高的部分会自动被裁剪，是一种比较“智能”的背景图片大小设置方式，通过配合“background-position”属性使用可以将开发者认为背景图像中“更重要”的部分通过定位显示出来。

  ````

* background-position: 50% 50%

  ```
  - 百分比单位
    用法如：“0% 50%”，设置背景图在元素内“水平方向”的“左方”，垂直方向的“中心”；“50% 50%”,，设置背景图在元素内的“中心”；“100% 100%”,，设置背景图在元素内的“右下方”。

  - 像素单位
    背景图的“左上角”相对于元素“左上角”偏移的距离，如“10px 20px”，设置背景图“水平向右”偏移10像素，“垂直向下”偏移20像素。

  ```

##### 背景固定

 `background-attachment` 属性用于固定背景图，其主要有两个值：

- fixed：页面出现滚动条后就算页面滚动，背景图也会固定在原来的位置不会跟随页面滚动。
- scroll：默认值，当页面滚动的时候，背景图也跟随页面同步滚动。



##### 背景组合值

```css
background: color image repeat attachment position;
```



##### 元素渐变

```css
.t3 {  background: linear-gradient(to bottom right, red, green, blue);  }
```

* 重复线性渐变

  ```css
  .t3 {  background: repeating-linear-gradient(to top right, #000 0px, #fff 20px, #808080 40px);  }
  ```


```css
background: radial-gradient(closest-corner circle at center center, #fff, #000);
```

##### 弹性布局

* flex-wrap： wrap：换行，第一行在上方
* justify-content：`flex-start`（默认值）：左对齐  `flex-end`：右对齐`space-between`：两端对齐，子元素之间的间隔都相等。`center`： 居中`space-around`：每个子元素两侧的间隔相等。所以，子元素之间的间隔比项目与边框的间隔大一倍。
* align-items：`flex-start`：交叉轴的起点对齐。`flex-end`：交叉轴的终点对齐。

##### 过渡特效transition

 ```css
  transition: background-color .5s ease-out 0s, border-radius .35s ease-in 0s;
 ```

#####变形转换 transform

```
transform: translate( x, y )：同时设置元素在X轴和Y轴方向的偏移
```

- **rotateX( angle )**：设置元素在X轴方向的旋转
- **rotateY( angle )**：设置元素在Y轴方向的旋转
- **rotateZ( angle )**：设置元素在Z轴方向的旋转

- **sclaeX ( x )**：设置元素在X轴方向的缩放
- **sclaeY ( y )**：设置元素在Y轴方向的缩放
- **sclae ( x, y )**：设置元素在X轴及Y轴方向的缩放
- **skewX( angle )**：设置元素在水平轴方向的倾斜
- **skewY( angle )**：设置元素在垂直轴方向的倾斜
- **skew( x-angle, y-angle )**：设置元素在水平轴及垂直轴方向的倾斜



* transfrom-style:preserve-3d：表示所有子元素在3D空间中呈现。



##### 动画

```
 @keyframes   name{
   from{}
     to{}
}
```



* *animation: 动画名称 持续时间 线性规律 延迟时间 播放次数 周期逆向播放 播放/暂停 首帧预设/末帧保留；*

infinite：表示在执行某事件后“无限次”执行动画。

 ``` animation: shine 1s linear infinite;```



#####响应式布局

  CSS3-Media Queries

```&lt;meta namhetme=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1,user-scalable=no&quot;&gt;
<head>
  	<meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no">
</head>
```

```css
@media 设备名 only(选取条件)|not(选取条件)|and(设备选取条件) {}
```

```css
/*1、当设备屏幕小于1180px时会采用该样式*/
@media screen and (max-width:1180px) { css codes }

/* 2、当设备屏幕大于850px时会采用该样式 */
@media screen and (min-width:850px) {  css codes }

/* 3、当设备屏幕大于850px,小于1180px时会采用该样式 */
@media screen and (min-width:850px) and (max-width:1180px) {  css codes }

/* 4、仅当电脑、手机、平板设备屏幕小于1180px时会采用该样式 */
@media only screen and (max-width:1180px) { css codes }
/* 6、专门针对iphone4的移动设备 */
<link rel="stylesheet" media="only screen and (-webkit-min-device-pixel-ratio:2)" type="text/css" href="iPhone4.css">
```

* 横排竖屏判断

  ```js
  //判断手机横竖屏状态：
  window.addEventListener("onorientationchange" in window ? "orientationchange" : "resize", function() {
          if (window.orientation === 180 || window.orientation === 0) {
              alert('竖屏状态！');
          }
          if (window.orientation === 90 || window.orientation === -90 ){
              alert('横屏状态！');
          } 
      }, false);
  //移动端的浏览器一般都支持window.orientation这个参数，通过这个参数可以判断出手机是处在横屏还是竖屏状态。
  ```

  ```css
  /*竖屏*/
  @media screen and (orientation:portrait) {
      
  }
  /*横屏*/
  @media screen and (orientation:landscape) {
      
  }
  ```










#####浏览器兼容性

- 1、-moz代表firefox浏览器私有属性
- 2、-ms代表ie浏览器私有属性
- 3、-webkit代表safari、chrome私有属性

浏览器 CSS 兼容前缀

```
-o-transform:rotate(7deg); // Opera

-ms-transform:rotate(7deg); // IE

-moz-transform:rotate(7deg); // Firefox

-webkit-transform:rotate(7deg); // Chrome safari

transform:rotate(7deg); // 统一标识语句
```



1、Normalize.css

* { margin: 0; padding: 0; } 

求窗口大小的兼容写法

```
// 浏览器窗口可视区域大小（不包括工具栏和滚动条等边线）
// 1600 * 525
var client_w = document.documentElement.clientWidth || document.body.clientWidth;
var client_h = document.documentElement.clientHeight || document.body.clientHeight;

// 网页内容实际宽高（包括工具栏和滚动条等边线）
// 1600 * 8
var scroll_w = document.documentElement.scrollWidth || document.body.scrollWidth;
var scroll_h = document.documentElement.scrollHeight || document.body.scrollHeight;

// 网页内容实际宽高 (不包括工具栏和滚动条等边线）
// 1600 * 8
var offset_w = document.documentElement.offsetWidth || document.body.offsetWidth;
var offset_h = document.documentElement.offsetHeight || document.body.offsetHeight;

// 滚动的高度
var scroll_Top = document.documentElement.scrollTop||document.body.scrollTop;
```



##### **常见兼容性问题？** 

1）png24位的图片在IE6浏览器上出现背景； 解决方案是：做成PNG8； 

2）浏览器默认的 margin 和 padding 不同。 解决方案是：加一个全局的*{margin:0;padding:0;}来统一。 

3）IE6双边距bug：块属性标签float后，又有横行的 margin 情况下，在 IE6 显示 margin 比设置的大。浮动IE产生的双倍距离 #box{float:left;width:10px;margin:0 0 0 100px;} 这种情况下IE6会产生200px的距离。 解决方法：加上_display：inline，使浮动忽略 

4）IE下，可以使用获取常规属性的方法来获取自定义属性，也可以使用getAttribute()获取自定义属性； Firefox下，只能使用getAttribute()获取自定义属性。 解决方法：统一通过getAttribute()获取自定义属性。

 5）IE下，even对象有x，y属性，但是没有pageX，pageY属性，但是没有x，y属性； 解决方法：（条件注释）缺点是在IE浏览器下可能会增加额外的HTTP请求数。

 6）Chrome中文界面下默认会将小于 12px 的文本强制按照 12px 显示 解决方法：可通过加入 CSS 属性 -webkt-text-size-adjust:none;解决

 7）超链接访问过后 hover 样式就不出现了，被点击访问过的超链接样式不在具有 hover 和 active ； 解决方法：改变CSS属性的排列顺序：L-V-H-A: a:link{ }  a:visited{ } a:hover{ } a:active{ }  



#####可继承的样式：  

 font-size font-family color, UL LI DL DD DT

#####不可继承的样式： 

border padding margin width height



#####**css3有哪些新特性？**

 答案解析： CSS3 实现圆角（border-radius:8px;），阴影（box-shadow:10px）,对文字加特效（text-shadow）,线性渐变（gradient），旋转（transform） transform:rotate(9deg) scale(0.85,0.90) translate(0px,-30px) skew(-9deg,0deg);//旋转，缩放，定位，倾斜 增加了更多的 css 选择器 多背景 rgba 





#####**CSS3新增伪类举例：**

 答案解析： p:first-of-type   选择属于其父元素的首个 <p> 元素的每个 <p> 元素； p:last-of-type   选择属于其父元素的最后 <p> 元素的每个 <p> 元素； p:only-of-type  选择属于其父元素唯一的 <p> 元素的每个 <p> 元素； p:only-child    选择属于其父元素的唯一子元素的每个 <p> 元素； p:nth-child(2)  选择属于其父元素的第二个子元素的每个 <p> 元素； :enabled  :disabled 控制表单控件的禁用状态； :checked        单选框或复选框被选中。 







#### js基础

JavaScript是一种轻量级的脚本语言。所谓“脚本语言”，指的是它不具备开发操作系统的能力，而是只用来编写控制其他大型应用程序的“脚本”。、

* var 声明变量
* JavaScript 允许重复定义变量，如果重复定义，之前的值将会被覆盖，如果只定义不赋值，则新定义的变量无效：



JavaScript变量分为“局部变量”和“全局变量”。所谓“局部变量”就是指所定义的变量只会在一个限定的范围内生效，通常指在某一个函数（function）内。而通过全局的方法或者其它函数是无法获取该变量的值的。





##### 基础数据类型

6种  number   string  boolean  object  function   undefined

boolean除了以下六个值的转换结果为 `false` ，其他的值全部为 `true`。

- **undefined**
- **null**
- **-0**
- **0**或**+0**
- **NaN**
- **''**（空字符串）



parseInt （） 和 Number（）

`parseInt()` 方法对内部的数值依次向右转换，一旦遇到**“非数字 ”**的字符（甚至包含小数点***“.”***）立即将之前取到的值返回。但如果第一位出现的字符就是“非数字”，那返回的结果就是 `NaN`，除了为**“正负号 ”**的情况。



##### 字符串

数组和字符串是可以互相转换的，这就需要用到两个方法：`split()` 和 `join()`：

```js
// 1、split 将字符串转换为数组

var result;
var str = "HTML,CSS,JavaScript,jQuery";

result = str.split();
console.log(result); // ["HTML,CSS,JavaScript,jQuery"]

result = str.split(',');
console.log(result); // ["HTML", "CSS", "JavaScript", "jQuery"]

// 2、join 将数组转换为字符串

var arr = ["152", "2888", "5771"];

result = arr.join();
console.log(result); // "152,2888,5771"

result = arr.join('-');
console.log(result); // "152-2888-5771"
```



##### 什么是unicode码

JavaScript 允许采用 `\uxxxx` 形式表示一个字符，其中 `xxxx` 表示字符的 Unicode 码点，每个Unicode码都有各自对应的字符，如  `\u00A9` 就是用于输出版权符号“©”的。

###### #转 义符

```js
\0（或：\u0000）用于表示：null

\b（或：\u0008）用于表示：后退键

\f（或：\u000C）用于表示：换页符

\n（或：\u000A）用于表示：换行符

\r（或：\u000D）用于表示：回车键

\t（或：\u0009）用于表示：制表符

\v（或：\u000B）用于表示：垂直制表符

\'（或：\u0027）用于表示：单引号

\"（或：\u0022）用于表示：双引号

\\ （或：\u005C）用于表示：反斜杠
```



`\uxxxx` 这种表示法只限于码点在`\u0000`~`\uFFFF`之间的字符。超出这个范围的字符，必须用两个双字节的形式表示。十六进制



##### 字符串查询



* str.charAt(index);
* str.indexof('ssssssi',5);
* str.indexof('isssssssss');

```js
var s = new String("abc");
s.charAt(0); // a
s.charAt(s.length - 1); // c

var str = 'Hello, world!';

str.indexOf('l', 5); // 10
str.lastIndexOf('l', 5) // 3

var str = "abc";

str.match("ab"); // ["ab"]
str.match("ac"); // null

var str = 'Hello, china!';

str.search('china'); // 7
str.search('world'); // -1



var website = "http://www.baidu.com";
// 查询头部
//  reg -> /^条件/
console.log(/^http/.test(website));

// 查询尾部
// reg -> /条件$/
console.log(/com$/.test(website));

// 查询是否包含
// reg -> /条件/
console.log(/baidu/.test(website));
```



#####slice()

```js
'JavaScript'.slice(0, 4) // "Java"
'JavaScript'.slice(4) // "Script"
'JavaScript'.slice(-6) // "Script"
'JavaScript'.slice(0, -6) // "Java"
'JavaScript'.slice(-2, -1) // "p"
如果第一个参数大于第二个参数，slice 方法返回一个空字符串。
如果参数是负值，表示从结尾开始倒数计算的位置，即该负值加上字符串长度。
```



##### subString()

```js
'JavaScript'.substring(4) // "Script"
'Javascript'.substring(-3) // "JavaScript"
'JavaScript'.substring(4, -3) // "Java"
如果参数是负数，substring 方法会自动将负数转为0。
如果第二个参数大于第一个参数，substring 方法会自动更换两个参数的位置。
```

##### **trim** 

方法用于去除字符串两端的空格，返回一个新字符串，不改变原字符串。

```js
'  Hello world!'.trim() // "Hello world!"
```

##### replace()

**replace** 方法用于字符串替换，其语法形式为：`replace(search, replacement)

```js
var str = "Hello, world!";
str.replace("world", "china"); // "Hello, china!"
```



Base64转码  所以更多时候都将其作为一种加密手段在使用。



##### 数组

- `push()`：在数组的末端添加一个或多个元素，并返回添加新元素后的数组长度*（ 改变原数组）*。
- `unshift()`：在数组的开始位置添加一个或多个元素，并返回添加新元素后的数组长度*（ 改变原数组）*。
- `apply()`：合并数组（只能合并两个）*（ 改变原数组）*
- `concat()`：合并数组（允许合并多个数组） *（ 不改变原数组）*

- `pop()`：删除数组最后一个元素*（ 改变原数组）*。
- `shift()`：删除数组第一个元素*（ 改变原数组）*。
- `splice()`：范围删除*（ 改变原数组）*。



```js
var arr = [1, 3, 4];
arr.splice(1, 0, 2);
console.log(arr); // [1, 2, 3, 4]
```



######slice()

```js
var arr = [1, 2, 3, 4, 5, 6];
arr.slice(0, 3);  // [1, 2, 3]
arr.slice(3, -1); // [4, 5]
arr.slice(3); // [4, 5, 6]
arr.slice(3, 1); // []
```

#####函数

定义函数时，圆括号内的参数为形参，调用函数时，圆括号内的参数为实参，具有确定的值。



* 对位传参法



##### 闭包函数



由于在JavaScript语言中，只有函数内部的子函数才能读取内部变量，因此可以把闭包简单理解成 “**定义在一个函数内部的函数即为闭包**”。



闭包最大的特点，就是它可以“记住”诞生的环境，比如 func\_2 记住了它诞生的环境 func\_1，所以从 func\_2 可以得到 func\_1 的内部变量。在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。



闭包的最大用处有两个，一个是可以读取函数内部的变量，另一个就是让这些变量始终保持在内存中，即闭包可以使得它诞生环境一直存在。请看下面的例子，闭包使得内部变量记住上一次调用时的运算结果。



##### 构造函数

，**Person** 就是构造函数，它提供模板，用来生成对象实例。为了与普通函数区别，构造函数名字的第一个字母通常大写。

构造函数的特点有两个。

- 函数体内部使用了 `this` 关键字，代表了所要生成的对象实例。

- 生成对象的时候，必需用 `new` 命令调用 `Person` 函数。


##### 对象

JavaScript的所有数据都可以被视为对象。简单说，所谓对象，就是一种 **无序** 的数据集合，由若干个“ **键值对** ”（key-value，亦称属性名值对、成员等）构成。





##### 原型链

JavaScript 原生提供一个Object对象，所有其他对象都继承自这个对象。Object本身也是一个构造函数，可以直接通过它来生成新对象。



由于  \_\_proto__  是任何对象都有的属性，而 js 里万物皆对象，所以会形成一条由  \_\_proto__  连起来的链条，递归访问  \_\_proto__  必须最终到头，并且值是` null `。



##### 对象继承

* 构造函数继承

* * 使用call或apply方法，将父对象的构造函数绑定在子对象上，即在子对象构造函数中加一行：

    ````js
    function Cat(name,color){
        // 继承 Animal
        Animal.apply(this, arguments);
        this.name = name;
        this.color = color;
    }
    var cat = new Cat("小黄", "黄色");
    console.log(cat.species); // 动物
    ````

  * prototype 模式

    ````js
    // 将Cat的prototype指向Animal的一个实例
    // 它相当于完全删除了prototype 对象原先的值，然后赋予一个新值。
    Cat.prototype = new Animal();

    // 任何一个prototype对象都有一个constructor属性，指向它的构造函数。
    // 如果没有这一行，Cat.prototype.constructor是指向Animal的；
    // 加了这一行以后，Cat.prototype.constructor指向Cat。
    Cat.prototype.constructor = Cat;

    var cat = new Cat("小黄","黄色");
    console.log(cat1.species); // 动物
    ````

  * 直接继承 prototype

    ```js
    function Animal(){ }
    Animal.prototype.species = "动物";

    Cat.prototype = Animal.prototype;
    Cat.prototype.constructor = Cat;
    var cat = new Cat("小黄","黄色");
    alert(cat1.species); // 动物
    ```

  * 利用空对象作为中介

    ```js
    var F = function(){};
    F.prototype = Animal.prototye;
    Cat.prototype = new F();
    Cat.prototype.constructor = Cat;
    ```

  * 拷贝继承

    ```js
    function Animal(){}
    Animal.prototype.species = "动物";
    function extend(Child, Parent) {
        var p = Parent.prototype;
        var c = Child.prototype;
        for (var key in p) {
          c[key] = p[key];
        }
        c.uber = p;
    }
    extend2(Cat, Animal);
    var cat1 = new Cat("小黄","黄色");
    alert(cat1.species); // 动物

    ```

* 非构造函数继承

* * Object 方法

  * ```js
    function object(o) {
        function F() {}
        F.prototype = o;
        return new F();
    }
    var Doctor = object(Chinese);
    Doctor.career = '医生';
    console.log(Doctor.nation); // 中国
    ```

  * 浅拷贝

  * ```js
    function extendCopy(parent) {
        var child = {};
        for (var key in parent) { 
        child[key] = parent[key];
        }
        child.uber = parent;
        return child;
    }
    var Doctor = extendCopy(Chinese);
    Doctor.career = '医生';
    console.log(Doctor.nation); // 中国
    ```

  * 深拷贝

  * ```js
    function deepCopy(parent, child) {
        var child = child || {};
        for (var key in parent) {
            if (typeof parent[key] === 'object') {
                child[key] = (parent[key].constructor === Array) ? [] : {};
                // 递归调用
                deepCopy(parent[key], child[key]);
            } else {
                child[key] = parent[key];
            }
        }
        return child;
    }
    Chinese.birthPlaces = ['北京','上海','香港'];
    Doctor.birthPlaces.push('厦门');
    console.log(Doctor.birthPlaces);  // 北京, 上海, 香港, 厦门
    console.log(Chinese.birthPlaces); // 北京, 上海, 香港
    ```

  * ​



##### data()

- **getTime()**：返回距离1970年1月1日00:00:00的毫秒数，等同于`valueOf`方法。
- **getDate()**：返回实例对象对应每个月的几号（从1开始）。
- **getDay()**：返回星期几，星期日为0，星期一为1，以此类推。
- **getYear()**：返回距离1900的年数。
- **getFullYear()**：返回四位的年份。
- **getMonth()**：返回月份（0表示1月，11表示12月）。
- **getHours()**：返回小时（0-23）。
- **getMilliseconds()**：返回毫秒（0-999）。
- **getMinutes()**：返回分钟（0-59）。
- **getSeconds()**：返回秒（0-59）。
- **getTimezoneOffset()**：返回当前时间与UTC的时区差异，以分钟表示，返回结果考虑到了夏令时因素。

 Date对象提供了一系列 `set` 方法，用来设置实例对象的各个方面。

- **setDate(date)**：设置实例对象对应的每个月的几号（1-31），返回改变后毫秒时间戳。
- **setYear(year)**: 设置距离1900年的年数。
- **setFullYear(year [, month, date])**：设置四位年份。
- **setHours(hour [, min, sec, ms])**：设置小时（0-23）。
- **setMilliseconds()**：设置毫秒（0-999）。
- **setMinutes(min [, sec, ms])**：设置分钟（0-59）。
- **setMonth(month [, date])**：设置月份（0-11）。
- **setSeconds(sec [, ms])**：设置秒（0-59）。
- **setTime(milliseconds)**：设置毫秒时间戳。

Math.random() // 0.3347085359643469



##### 定时器与本地存储

* 延时调用

* setTimeout()

* ```js
  // 或写成
  setTimeout("printText()", 1000);
  // 接收延时函数
  var timeout;

  btn1.onclick = function() {
  	// 执行延时函数
  	timeout = setTimeout(function() {
  		printText();
  	}, 2000);
  }
  btn2.onclick = function() {
  	// 取消延时函数
  	clearTimeout(timeout);
  }

  ```

* 定时器 setInterval()

* ```js
  var n = 10;
  var interval;
  interval = setInterval(function(){
  	if (n == 0) {
  		this.clearInterval(interval);
  		console.log('定时器停止！');
  	}else {
  		console.log(--n);
  	}
  }, 1000);
  ```

* ```js
  sessionStorage.setItem("name", "Henrry Lee");
  // 获取临时存储的数据
  var msg = sessionStorage.getItem("name");
  sessionStorage.removeItem('name')
  sessionStorage.getItem('name')
  sessionStorage.clear()

  var obj = {
  	name: "Henrry Lee",
  	age: 24,
  	address: "四川省成都市"
  }
  // 转成JSON字符串格式
  var strObj = JSON.stringify(obj);
  localStorage.setItem("userInfo", strObj);

  // 访问
  var storageStrObj = localStorage.getItem("userInfo");
  // 将JSON字符串转为JS对象
  var jsObj = JSON.parse(storageStrObj);
  console.log(jsObj);
  ```

* 



##### 事件

* 事件添加

 1）、直接将代码写在HTMl上，在页面标签元素的 “*on-*” 属性上添加

2）、通过DOM元素添加

```js
document.getElementsByTagName('input')[0].oninput = function() {
    // 事件处理
    // ...
    alert("处理input事件！");
}
```

3）、通过实例化过后的Element对象添加

```js
var ipt = document.getElementsByTagName('input')[0];
var btn = document.getElementsByTagName('button')[0];

ipt.onchange = function() {
    // 事件处理
    // ...
    alert("处理input事件！");
}
btn.onclick = function() {
    // 事件处理
    // ...
    alert("处理click事件！");
}
```

4）、对实例化过后的Element对象进行监听

```js
var ipt = document.getElementsByTagName('input')[0];
var btn = document.getElementsByTagName('button')[0];

ipt.addEventListener('input', function() {
    // 事件处理部分
    // ... 
    alert("处理input事件！");
}, false);
btn.addEventListener('click', function() {
    // 事件处理部分
    // ... 
    alert("处理click事件！");
}, false);
```



##### 事件监听





```js
var btn = document.getElementsByTagName('button')[0];
	btn.addEventListener('click', func_1, false);
    // 移除监听函数，点击按钮不会触发监听函数
	btn.removeEventListener('click', func_1, false);
	function func_1() {
		console.log("测试函数");
	}
```

#####事件传播

- 第一阶段：从window对象传导到目标节点，称为“捕获阶段”
- 第二阶段：在目标节点上触发，称为“目标阶段”
- 第三阶段：从目标节点传导回window对象，称为“冒泡阶段”



 使用事件对象的 `event.stopPropagation()` 方法可以让事件传播到当前的节点为止，不再继续传播。语法结构如下：

```javascript
event.stopPropagation();
```

  但是，*stopPropagation()*方法只会阻止当前监听函数的传播，不会阻止\<p>节点上的其他click事件的监听函数。如果想要不再触发那些监听函数，可以使用*stopImmediatePropagation()*方法。语法与*stopPropagation()*方法一致。

##### 鼠标事件

click事件和dblclick事件

mouseup事件、mousedown事件

mouseover事件和mouseenter事件

mouseout事件和mouseleave事件

鼠标还提供与指针位置相关的一些属性

> - **clientX，clientY**
>
>   clientX属性返回鼠标位置相对于浏览器窗口左上角的水平坐标，单位为像素。
>
>   clientY属性返回鼠标位置相对于浏览器窗口左上角的垂直坐标，单位为像素。
>
> - **movementX，movementY**
>
>   movementX属性返回一个水平位移，单位为像素，表示当前位置与上一个mousemove事件之间的水平距离。在数值上，等于currentEvent.movementX = currentEvent.screenX - previousEvent.screenX。
>
>   movementY属性返回一个垂直位移，单位为像素，表示当前位置与上一个mousemove事件之间的垂直距离。在数值上，等于currentEvent.movementY = currentEvent.screenY - previousEvent.screenY。
>
> - **screenX，screenY**
>
>   screenX属性返回鼠标位置相对于屏幕左上角的水平坐标，单位为像素。
>
>   screenY属性返回鼠标位置相对于屏幕左上角的垂直坐标，单位为像素。

##### 键盘事件

- **（1）、keydown事件**

  按下键盘时触发该事件。

- **（2）、keypress事件**

  只要按下的键并非Ctrl、Alt、Shift和Meta，就接着触发keypress事件。

- **（3）、keyup事件**

  如果用户一直不松开键盘，键盘事件就会按照这样的顺序连续触发：keydown -> keypress -> keydown-> keypress -> ... （松开键盘后）-> keyup。



##### 表单事件

- **（1）、input事件**

  input事件当\<input>、\<textarea>的值发生变化时触发。此外，将contenteditable属性设置为“true”的非表单元素，只要值发生变化，也会触发input事件。input事件的一个特点，就是会连续触发，比如用户每次按下一次按键，就会触发一次input事件。

- **（2）、select事件**

  select事件当在\<input>、\<textarea>中选中文本时触发。

- **（3）、Change事件**

  Change事件当\<input>（单选框和复选框）、\<select>、\<textarea>（需要失去焦点时触发）的值发生变化时触发。它与input事件的最大不同，就是不会连续触发，只有当全部修改完成时才会触发，而且input事件必然会引发change事件。

- **（4）、reset事件**

  reset事件只能发生在表单元素\<form>上，当表单重置（所有表单成员变回默认值）时触发。

- **（5）、submit事件**

  submit事件只能发生在表单元素\<form>上，当表单数据向服务器提交时触发。注意，submit事件的发生对象是\<form>，而不是\<button>，因为提交的是表单，而不是按钮。

##### 窗口事件

- **（1）、load事件和error事件**

  load事件在页面加载成功时触发，error事件在页面加载失败时触发。页面从浏览器缓存加载，并不会触发load事件。

  这两个事件实际上属于进度事件，不仅发生在document对象，还发生在各种外部资源上面。浏览网页就是一个加载各种资源的过程，图像、样式表、脚本、视频、音频、Ajax请求等等。这些资源和document对象、window对象、XMLHttpRequestUpload对象，都会触发load事件和error事件。

- **（2）、unload事件**

  unload事件在窗口关闭或者document对象将要卸载时触发，发生在window、body、frameset等对象上面。它的触发顺序排在beforeunload、pagehide事件后面。unload事件只在页面没有被浏览器缓存时才会触发，换言之，如果通过按下“前进/后退”导致页面卸载，并不会触发unload事件。

- **（3）、DOMContentLoaded事件**

  当HTML文档下载并解析完成以后，就会在document对象上触发DOMContentLoaded事件。这时，仅仅完成了HTML文档的解析（整张页面的DOM生成），所有外部资源（样式表、脚本、iframe等等）可能还没有下载结束。也就是说，这个事件比load事件，发生时间早得多。

  需要注意的是，网页的JavaScript脚本是同步执行的，所以定义DOMContentLoaded事件的监听函数，应该放在所有脚本的最前面。否则脚本一旦发生堵塞，将推迟触发DOMContentLoaded事件。

- **（4）、readystatechange事件**

  readystatechange事件发生在Document对象和XMLHttpRequest对象加载完成后，当它们的readyState属性发生变化时触发。

  IE8不支持DOMContentLoaded事件，但是支持这个事件。因此，可以使用readystatechange事件，在低版本的IE中代替DOMContentLoaded事件。

- **（5）、scroll事件**

  scroll事件在文档或文档元素滚动时触发，可以是鼠标滚轮触发的滚动，也可以是用户用鼠标拖动滚动条。

- **（6）、resize事件**

  resize事件在改变浏览器窗口大小时触发，可以发生在window、body对象上面。

- **（7）、beforeunload事件**

  页面刷新或关闭时触发。



#####焦点事件

- **（1）、focus事件和focusin事件**

  当元素获得焦点的时候触发。区别在于focus事件不会冒泡，而focusin事件（老版火狐浏览器不支持）会冒泡。focusin事件发生在focus事件之前。

  这两个事件对象都含有一个*target*属性，返回当前执行事件元素的元素节点。

- **（2）、blur事件和focusout事件**

  当元素失去焦点的时候触发。区别在于blur事件不会冒泡，而focusout事件（老版火狐浏览器不支持）会冒泡。focusout事件发生在blur事件之前。

  这两个事件对象也含有一个target属性，返回内容同上。



##### Dom



* 节点
* 节点的类型有七种：
  - **Document**：整个文档树的顶层节点
  - **DocumentType**：*doctype* 标签（比如 `<!DOCTYPE html>` ）
  - **Element**：网页的各种HTML标签（比如 `<body>`、`<a>`等）
  - **Attribute**：网页元素的属性（比如 `class="right"` ）
  - **Text**：标签之间或标签包含的文本
  - **Comment**：注释
  - **DocumentFragment**：文档的片段



* 节点树
* 除了根节点以外，其他节点对于周围的节点都存在三种关系。
  - **父节点关系 parentNode**：直接的那个上级节点
  - **子节点关系 childNodes**：直接的下级节点
  - **同级节点关系 sibling**：拥有同一个父节点的节点



DOM提供操作接口，用来获取三种关系的节点其中，子节点接口包括 **firstChild**（第一个子节点）和**lastChild**（最后一个子节点）等属性，同级节点接口包括 **nextSibling**（紧邻在后的那个同级节点）和 **previousSibling**（紧邻在前的那个同级节点）属性。



* 节点集合

* DOM提供两种集合对象，用于实现这种节点的集合：NodeList  和 HTMLCollection。

* * **Node.firstChild & Node.firstElementChild** 
  * 获取当前节点的第一个子节点。二者的区别在于前者包括了文本节点和注释节点。
  * **Node.lastChild & Node.lastElementChild**
  * **Node.previousSibling & Node.previousElementSibling**
  * **Node.parentNode** 
  * **Node.parentElement**
  * 只有Element节点才有该属性，其他浏览器则是所有类型的节点都有该属性。
  * **Node.childElementCount*

* 节点生成

*  以下方法可以用于生成DOM节点：

  - **document.createElement()**：该方法用来生成HTML元素节点，该方法的参数为元素的标签名，即元素节点的tagName属性。
  - **document.createTextNode()**：该方法用来生成文本节点，参数为所要生成的文本节点的内容。
  - **document.createAttribute()**：该方法生成一个新的属性对象节点，该方法的参数是属性的名称。属性生成后可以用value属性为其赋值。

* DOM Attribute

* * **Element.attributes**

    元素属性集合，`Element.attributes[idx]` 返回属性节点对象。属性节点对象有 `name` 和 `value` 属性，*name* 属性用于访问属性节点对象名，该属性只读。*value* 属性用于访问或设置该属性节点对象值。

  * **Element.getAttribute()**

    该方法返回当前元素节点的指定属性。如果指定属性不存在，则返回null。参数为指定的属性名称。

  * **Element.setAttribute()**

    该方法用于为当前元素节点新增属性。如果同名属性已存在，则相当于编辑已存在的属性。该方法含有两个参数，第一个参数表示属性名，第二个参数表示需要对属性设置的值。

  * **Element.setAttributeNode()**

    该方法用于为当前元素节点新增属性，参数为通过 *document.createAttribute()* 创建的属性节点。

  * **Element.hasAttribute()**

    该方法返回一个布尔值，表示当前元素节点是否包含指定属性。参数为指定的属性名称。

  * **Element.removeAttribute()**

    该方法用于移除属性节点。

  * **dataset属性**

    dataset 属性用于获取或设置用户自定义的属性名（data-*）,该属性设置属性名和 `setAttribute()` 方法不同，它是通过赋值的方式实现的。

* DOM Element

* * **Element.attributes**：该属性返回当前元素所有属性节点的一个类似数组对象。

  * **Element.id**：该属性返回指x定元素的id属性，是一个可读可写的属性。

  * **Element.tagName**：该属性返回指定元素的大写标签名，与 nodeName 属性的值相等。但在事件对象（event）上通常使用tagName更加常见。

  * **Element.innerHTML**：该属性返回该元素包含的HTML代码。该属性可读写，常用来设置某个Element节点的内容。如果将该属性设为空字符串，等于删除了它包含的所有节点。

  * **Element.outerHTML**：该属性返回一个字符串，内容为指定元素节点的所有HTML代码，包括它自身和包含的所有子元素。该属性是同样是可读可写的，对它进行赋值，等于替换掉当前元素。但是如果该Element节点已经被赋值给一个变量了，在使用outerHTML替换原来的标签后，之前的变量值还是能够访问，也就是说被替换掉的内容依然保存于内存。(了解)

  * **Element.matches()**：该方法用于匹配当前的Element节点是否匹配方法参数内的CSS选择器字符串，CSS选择器必须是完整的选择符（如id前需要加上“#”，class前面要加上“.”，属性选择器要用“[]”括起来等）。它返回的是一个布尔值。

  * **Element.scrollIntoView()**

    该方法滚动当前元素，进入浏览器的可见区域，类似于设置window.location.hash的效果。

    该方法可以接受一个布尔值作为参数。如果为true，表示元素的顶部与当前区域的可见部分的顶部对齐（前提是当前区域可滚动）；如果为false，表示元素的底部与当前区域的可见部分的尾部对齐（前提是当前区域可滚动）。如果没有提供该参数，默认为true。

  * **Element.focus()**

    该方法可以让元素获得焦点。用户使用键盘Tab键可以切换获得焦点的元素，都可以使用该方法来获得焦点。

  * **Element.hasChildNodes()**

    该方法返回一个布尔值，表示当前节点是否有子节点。

  * **Element.cloneNode()** 

    该方法用于克隆一个节点。它接受一个布尔值作为参数，表示是否同时克隆子节点，默认是 false，即不克隆子节点。克隆一个节点之后，DOM树有可能出现两个有相同ID属性的HTML元素，这时应该修改其中一个HTML元素的ID属性。

  * **Element.contains()**

    该方法接受一个节点作为参数，返回一个布尔值，表示参数节点是否为当前节点的后代节点。需要注意的是，如果将当前节点传入contains方法，也会返回true。

  * **Element.isEqualNode()**

    该方法返回一个布尔值，用于检查两个节点是否相等。所谓相等的节点，指的是两个节点的类型相同、属性相同、子节点相同。

  * **Element.normalize()**  

    该方法用于清理当前节点内部的所有Text节点。它会去除空的文本节点，并且将毗邻的文本节点合并成一个。

* 1、插入节点

* * **Element.appendChild()**
  * **Element.before()**
  * **Element.after()**
  * **Element.insertBefore()**

* 2、替换节点

* * **Element.replaceWith()**
  * **Element.replaceChild()**
  * **Element.remove()**
  * **Element.removeChild()**

* DOM Text

* * **nodeValue**：设置/获取文本值，只有文本节点和注释节点才有 nodeValue 属性，元素节点要获取文本值可通过 *el.firstChild.nodeValue* 获取。
  * **Element.textContent**：设置/获取当前元素节点及其后代节点文本内容。该属性会忽略标签。
  * **Element.innerText**：设置/获取当前元素节点及其后代节点文本内容。

#####bom

window对象下主要包含了以下子对象：

- **document**：文档对象
- **frames**：浏览器的框架（如iframe和现在废弃了的frameset）
- **history**：浏览器浏览历史对象
- **location**：浏览器页面所处位置对象
- **navigator**：浏览器信息导航对象
- **screen**：浏览器屏幕对象

- **window.innerWidth**：浏览器窗口的可见宽度
- **window.innerHeight**：浏览器窗口的可见高度
- **window.outerWidth**：浏览器窗口的实际宽度（包括浏览器菜单和边框）
- **window.outerHeight**：浏览器窗口的实际高度（包括浏览器菜单和边框）
- **window.window.pageXOffsett**：浏览器窗口滚动条水平滚动的距离
- **window.pageYOffset**：浏览器窗口滚动条垂直滚动的距离

```js
document.documentElement.scrollTop || document.body.scrollTop

/*隐藏滚动条*/
body::-webkit-scrollbar {
    display: none;
}
```



```js
// 窗口距离屏幕左侧
var scrMarginX = (typeof window.screenLeft == "number") ? window.screenLeft : window.screenX;
// 窗口距离屏幕右侧
var scrMarginY = (typeof window.screenTop == "number") ? window.screenTop : window.screenY;
```



```js
function testIPhone() {
	let navUserAgent = window.navigator.userAgent.toLowerCase();
	let isMobile = /Mobile/i.test(navUserAgent);
	let isIPhone = /iphone/i.test(navUserAgent);
	if (isMobile && isIPhone) {
		return "当前运行的环境为移动端，使用的手机为'iphone'.";
	}else if(isMobile) {
		return "当前运行的环境为移动端，使用的手机不是'iphone'.";
	}else {
		return "当前运行的环境不是移动端";
	}
}
```



##### 正则表达式

* **^**：表示字符串的开始位置
* **$**：表示字符串的结束位置
* |  或
* 【】任意一个      ```/[abc]/.test('Hello world') // false```
* `[^xyz]` 表示除了*x*、*y*、*z*之外都可以匹配。
* -连字符  `[abc]`可以写成`[a-c]`，
* **{n}**：表示恰好重复n次
* **{n,}**：表示至少重复n次
* **{n,m}**： 表示重复不少于n次，不多于m次。
* `?` 问号表示某个模式出现0次或1次，  等同于`{0, 1}`。
* `*` 星号表示某个模式出现0次或多次，等同于`{0,}`。
* `+` 加号表示某个模式出现1次或多次，等同于`{1,}`。
* i表示忽略大小    ```/abc/i.test('AbC') // true```






##### XHR

XMLHttpRequest 对象提供了对 HTTP 协议的完全的访问，包括做出 POST 和 HEAD 请求以及普通的 GET 请求的能力。XMLHttpRequest 可以同步或异步地返回 Web 服务器的响应，并且能够以文本或者一个 DOM 文档的形式返回内容。

######get

 xmlhttp=new XMLHttpRequest();

xmlhttp.open("GET","ajax_info.txt",true);  xmlhttp.send();

xmlhttp.send();

```js
规定请求的类型、URL 以及是否异步处理请求。
method：请求的类型；GET 或 POST
url：文件在服务器上的位置
async：true（异步）或 false（同步）
```



###### post

xmlhttp.open("POST","/try/ajax/demo_post2.php",true); xmlhttp.setRequestHeader("Content-type","application/x-www-form-urlencoded");

 xmlhttp.send("fname=Henry&lname=Ford");



document.getElementById("myDiv").innerHTML=xmlhttp.responseText;

| 属性           | 描述              |
| ------------ | --------------- |
| responseText | 获得字符串形式的响应数据。   |
| responseXML  | 获得 XML 形式的响应数据。 |



##### ajax

```js
$.ajax({ url: "test.html", context: document.body, success: function(){
        $(this).addClass("done");
      }});
```

```js
$(function(){
    $('#send').click(function(){
         $.ajax({
             type: "GET",
             url: "test.json",
             data: {username:$("#username").val(), content:$("#content").val()},
             dataType: "json",
             success: function(data){
                         $('#resText').empty();   //清空resText里面的所有内容
                         var html = ''; 
                         $.each(data, function(commentIndex, comment){
                               html += '<div class="comment"><h6>' + comment['username']
                                         + ':</h6><p class="para"' + comment['content']
                                         + '</p></div>';
                         });
                         $('#resText').html(html);
                      }
         });
    });
});
```













#####解决跨域问题

跨域是指从一个域名的网页去请求另一个域名的资源。比如从www.baidu.com 页面去请求 www.google.com 的资源。但是一般情况下不能这么做，它是由浏览器的同源策略造成的，是浏览器对[JavaScript](http://lib.csdn.net/base/javascript)施加的安全限制。跨域的严格一点的定义是：只要 协议，域名，端口有任何一个的不同，就被当作是跨域

* 跨域资源共享（CORS）

​          Access-Control-Allow-Origin 

```
只需要在后台中加上响应头来允许域请求！在被请求的Response header中加入以下设置，就可以实现跨域访问了！
//指定允许其他域名访问
'Access-Control-Allow-Origin:*'//或指定域
//响应类型
'Access-Control-Allow-Methods:GET,POST'
//响应头设置
'Access-Control-Allow-Headers:x-requested-with,content-type'
```



* 通过jsonp跨域

`       $.getJSON`方法会自动判断是否跨域，不跨域的话，就调用普通的`ajax`方法；跨域的话，则会以异步加载js文件的形式来调用`jsonp`的回调函数。 

```
 JSONP只能实现GET请求，
```

##### 原型链总结



构造函数里有一个属性prototype，这个属性里面存储着它原型对象的指针。这样构造函数就能找到原型对象。反过来，原型对象也有一个属性，constructor。这个属性指向构造函数的指针。

### 分清普通对象和函数对象的区别。

#### 凡事通过new Function () 创建的对象，都是函数对象，其他的都是普通对象。





每个函数对象都有prototype 属性。这个属性指向的是函数的原型对象，这里说的是函数对象，才有prototype 而还有一些不是函数对象，是普通的对象，所有的对象都有_proto这个属性，这个属性和prototype 一样指向的是原型对象。







构造函数的原型对象的constructor指向构造函数本身 Person.prototype.constructor == Person; 构造函数的实例化对象的proto属性指向构造函数的原型对象 person1.proto == Person.prototyoe;





### 箭头函数

es6中箭头函数和普通函数的区别

 

1.普通function的声明在变量提升中是最高的，箭头函数没有函数提升

2.箭头函数没有this，arguments

3.箭头函数不能作为构造函数，不能被new，没有property,

4.call和apply方法只有参数，没有作用域



普通函数中的this:

1. this总是代表它的直接调用者,  例如 obj.func , 那么func中的this就是obj

2.在默认情况，没找到直接调用者,  则this指的是 window

3.在严格模式下,没有直接调用者的函数中的this是 undefined

4.使用call,apply, bind(ES5新增)绑定的, this指的是 绑定的对象

箭头函数中的this

\1. 默认指向在定义时作用域, 它所处的对象,而不是执行时的对象, 定义它的时候,可能环境是window（即继承父级的this）;



原因：箭头函数不会自动绑定局部变量，如this，arguments，super(ES6)，new.target(ES6)等

所以箭头函数没有它自己的this值，箭头函数内的this值继承自外围作用域。在箭头函数中调用 this 时，仅仅是简单的沿着作用域链向上寻找，找到最近的一个 this 拿来使用







### JQ





##### 事件



鼠标事件

- .click() & .dblclick() ：单击 & 双击事件


- .mousedown()  & .mouseup() ：鼠标按下 & 鼠标抬起（提示：鼠标按下抬起会触发一个点击事件）

- .mousemove() ：鼠标移动事件（只要鼠标移动就会触发该事件，并且会触发多次）

- .mouseover()  & .mouseout() ：鼠标移入 & 鼠标移出

- .mouseenter & .mouseleave() ：鼠标移入 & 鼠标移出（不会冒泡）

- .hover() ：切换事件，类似于css中的hover，

  其语法形式为：*$(selector).hover(handlerIn, handlerOut)* ，在hover方法中传递两个回调函数即可。

键盘事件

- .keydown()  & .keyup() ：键盘按下 & 键盘抬起（当用户在一个元素上第一次按下/抬起键盘上的键的时候，就会触发）

  > 提示：
  >
  > 理论上它可以绑定到任何元素，但keydown/keyup事件只是发送到具有焦点的元素上，不同的浏览器中，可获得焦点的元素略有不同，但是表单元素总是能获取焦点，所以对于此事件类型表单元素是最合适的。

- .keypress() ：长按

**one事件**

```js
$("div").one("click", function(){
    // 这个事件只会触发一次
})
```

**多事件绑定**

**多个事件绑定同一个函数**

```javascript
$("#elem").on("mouseover mouseout", function(){ });
```

通过空格分离，传递不同的事件名，可以同时绑定多个事件。

**多个事件绑定不同函数**

```javascript
$("#elem").on({
    mouseover:function(){},  
    mouseout:function(){}
});
```

事件卸载

```js
$("elem").off()
```





##### 样式

* .hasClass()
* .addClass()
* .removeClass()
* .toggleClass() 一次执行，相当于addClass，再次执行相当于removeClass。

`.css()` 方法主要用于设置/获取DOM元素样式。

尺寸

- `.height()`：获取/设置匹配元素当前计算的高度值（px）
- `.innerHeight()`：获取第一个匹配元素内部区域高度（包括padding、不包括border）。
- `.outerHieght()`：获取第一个匹配元素外部高度（默认包括padding和border）。
- `.width()`：获取/设置第一个匹配元素当前计算的宽度值（px）。
- `.innerWidth()`：获取第一个匹配元素内部区域宽度（包括padding、不包括border）。
- `.outerWidth()`：获取第一个匹配元素外部宽度（默认包括padding和border）。
- `.scrollTop()`：设置/获取匹配元素相对滚动条顶部的偏移。
- `.scrollLeft()`：设置/获取匹配元素相对滚动条左侧的偏移。
- `offset()`：获取元素偏移，相对于文档而言，有四个选项（`.top, .left, .right, .bottom`）
- `position`：获取元素位置，相对于拥有定位属性的祖先级元素而言，有四个选项（`.top, .left, .right, .bottom`）

##### 动画

.hide([speed,[easing],[fn]])

.show([speed,[easing],[fn]])

**.toggle([speed,[easing],[fn]])**

**.slideToggle()**

slideDown与slideUp是一对相反的方法。需要对元素进行上下拉卷效果的切换，jQuery提供了一个便捷方法slideToggle用滑动动画显示或隐藏一个匹配元素。其语法形式为：

```
.slideToggle( [speed ] [, easing ] [, complete ] )
```

> 注意：
>
> 1. display属性值保存在jQuery的数据缓存中，所以display可以方便以后可以恢复到其初始值
> 2. 当一个隐藏动画后，高度值达到0的时候，display 样式属性被设置为none，以确保该元素不再影响页面布局

.fadeToggle( [speed ][, easing ] [, complete ] )

```js
$(".box").click(function () {
   $(this).animate({
       left: "+=50px"
   },1000, function () {
     alert("动画执行完毕！");
   })
});
```





### vue

* vuex
  * 我看来 **vuex** 就是把需要共享的变量全部存储在一个对象里面，然后将这个对象放在顶层组件中供其他组件使用 
  * 在vue的组件化开发中，经常会遇到需要将当前组件的状态传递给其他组件。父子组件通信时，我们通常会采用 **props** + **emit** 这种方式。但当通信双方不是父子组件甚至压根不存在相关联系， 

这个就是最基本也是完整的vuex代码；**vuex** 包含有五个基本的对象：

- **state**：存储状态。也就是变量；
- **getters**：派生状态。也就是set、get中的get，有两个可选参数：state、getters分别可以获取state中的变量和其他的getters。外部调用方式：**store.getters.personInfo()**。就和vue的computed差不多；
- **mutations**：提交状态修改。 SET_AGE(state, age) {  commit(age, age);  }
- 也就是set、get中的set，这是vuex中唯一修改state的方式，但不支持异步操作。第一个参数默认是state。外部调用方式：**store.commit('SET_AGE', 18)**。和vue中的methods类似。
- **actions**：和mutations类似。不过actions支持异步操作。第一个参数默认是和store具有相同参数属性的对象。外部调用方式：**store.dispatch('nameAsyn')**。
- **modules**：store的子模块，内容就相当于是store的一个实例。调用方式和前面介绍的相似，只是要加上当前子模块名，如：**store.a.getters.xxx()**。












### 组件动态挂载

















### this.$refs.



#####懒加载



- 既然懒加载的原理是基于判断元素是否出现在窗口可视范围内，首先我们写一个函数判断元素是否出现在可视范围内：

```js
import Vue from 'vue'
import App from './App.vue'
import VueLazyload from 'vue-lazyload'

Vue.use(VueLazyload)

// or with options
Vue.use(VueLazyload, {
  preLoad: 1.3,
  error: 'require('dist/error.png')',
  loading: 'dist/loading.gif',
  attempt: 1
})

new Vue({
  el: '#app',
  components: {
    App
  }
})

<template>
    <div>
        <img v-lazy="imgObj"/>
    </div>
</template>

<script>
export default {
    name: 'lazy',
    data() {
        return {
            // 引入图片，如果实在js中，必须require进来
            imgObj: {
                src: 'http://img3.imgtn.bdimg.com/gp=0.jpg',
                error: require('../assets/error.jpeg'),
                loading: require('../assets/loading.gif')
            }
        }
    }
}
</script>

<style scoped>

</style>




```





### 浏览器兼容







### 响应式布局

**1.布局及设置meta标签**

**2.通过媒体查询来设置样式media query**

**3.设置多种视图宽度**

```css
/**ipad**/
@media only screen and (min-width:768px)and(max-width:1024px){}
/**iphone**/
 @media only screen and (width:320px)and (width:768px){}
```

宽度不固定，可以使用百分比

**字体设置   **    rem

**图片处理**  图片液态化

1.

```css
#wrap img{
       max-width:100%;
       height:auto;
   }
```

2.

```
 background-size是css3的新属性，用于设置背景图片的大小，有两个可选值，第一个值用于指定背景图的width,第2个值用于指定背景图的height,如果只指定一个值，那么另一个值默认为auto。
  background-size:cover; 等比扩展图片来填满元素
  background-size:contain; 等比缩小图片来适应元素的尺寸
```



#####MVC和MVVM模式的区别

   

1，MVC （Model-View-Controller）

M - Model ：数据保存

V - View : 用户界面

C - Controller ： 业务逻辑

MVC ，用户操作> View (负责接受用户的输入操作)>Controller（业务逻辑处理）>Model（数据持久化）>View（将结果通过View反馈给用户）

![img](https://blog.csdn.net/qinyuhua93/article/details/78684200)

2，MVVM

M -Model

V - 

VM - 

MVVM是将“数据模型数据双向绑定”的思想作为核心，因此在View和Model之间没有联系，通过ViewModel进行交互，而且Model和ViewModel之间的交互是双喜那个的，因此试图的数据的变化会同事修改数据源，而数据源数据的变化也会立即反应到View上。



##### vue底层原理

Vue实现这种数据双向绑定的效果，需要三大模块：

1. **Observer**：能够对数据对象的所有属性进行监听，如有变动可拿到最新值并通知订阅者
2. **Compile**：对每个元素节点的指令进行扫描和解析，根据指令模板替换数据，以及绑定相应的更新函数
3. **Watcher**：作为连接Observer和Compile的桥梁，能够订阅并收到每个属性变动的通知，执行指令绑定的相应回调函数，从而更新视图





会对数据对象每个属性添加对应的get和set方法，对数据进行读取和赋值操作就分别调用get和set方法。

